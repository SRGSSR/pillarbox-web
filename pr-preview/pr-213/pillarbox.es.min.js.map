{"version":3,"file":"pillarbox.es.min.js","sources":["../src/components/player.js","../src/pillarbox.js","../src/dataProvider/model/MediaComposition.js","../src/dataProvider/services/DataProvider.js","../src/utils/Image.js","../src/utils/Drm.js","../src/utils/AkamaiTokenService.js","../src/utils/PlayerEvents.js","../src/analytics/SRGAnalytics.js","../src/lang/de.js","../src/lang/en.js","../src/lang/fr.js","../src/lang/it.js","../src/lang/rm.js","../src/middleware/srgssr.js"],"sourcesContent":["import videojs from 'video.js';\n\n/**\n * @ignore\n * @type {typeof import('video.js/dist/types/player').default}\n */\nconst vjsPlayer = videojs.getComponent('player');\n\n/**\n * This class extends {@link VideoJsPlayer}.\n *\n * @class Player\n */\nclass Player extends vjsPlayer {\n\n  /**\n   * A getter/setter for the media's audio track.\n   * Activates the audio track according to the language and kind properties.\n   * Falls back on the first audio track found if the kind property is not satisfied.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AudioTrack/kind\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AudioTrack/language\n   *\n   * @param {TrackSelector} [trackSelector]\n   *\n   * @example\n   * // Get the current audio track\n   * player.audioTrack();\n   *\n   * @example\n   * // Activate an audio track based on language and kind properties\n   * player.audioTrack({language:'en', kind:'description'});\n   *\n   * @example\n   * // Activate first audio track found corresponding to language\n   * player.audioTrack({language:'fr'});\n   *\n   * @return {AudioTrack|undefined}\n   */\n  audioTrack(trackSelector) {\n    const audioTracks = Array.from(this.player().audioTracks());\n\n    if (!trackSelector) {\n      return audioTracks.find((audioTrack) => audioTrack.enabled);\n    }\n\n    const { kind, language } = trackSelector;\n    const audioTrack =\n      audioTracks.find(\n        (audioTrack) =>\n          audioTrack.language === language && audioTrack.kind === kind\n      ) || audioTracks.find((audioTrack) => audioTrack.language === language);\n\n    if (audioTrack) {\n      audioTrack.enabled = true;\n    }\n\n    return audioTrack;\n  }\n\n  /**\n   * A getter/setter for the media's text track.\n   * Activates the text track according to the language and kind properties.\n   * Falls back on the first text track found if the kind property is not satisfied.\n   * Disables all subtitle tracks that are `showing` if the `trackSelector` is truthy but does not satisfy any condition.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack/kind\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/textTrack/language\n   *\n   * @param {TrackSelector} [trackSelector]\n   *\n   * @example\n   * // Get the current text track\n   * player.textTrack();\n   *\n   * @example\n   * // Disable all text tracks has a side effect\n   * player.textTrack('off');\n   * player.textTrack({});\n   *\n   * @example\n   * // Activate an text track based on language and kind properties\n   * player.textTrack({language:'en', kind:'captions'});\n   *\n   * @example\n   * // Activate first text track found corresponding to language\n   * player.textTrack({language:'fr'});\n   *\n   * @return {VideojsTextTrack|undefined}\n   */\n  textTrack(trackSelector) {\n    const textTracks = Array.from(this.player().textTracks()).filter(\n      (textTrack) => !['chapters', 'metadata'].includes(textTrack.kind)\n    );\n\n    if (!trackSelector) {\n      return textTracks.find((textTrack) => textTrack.mode === 'showing');\n    }\n\n    textTracks.forEach((textTrack) => (textTrack.mode = 'disabled'));\n\n    const { kind, language } = trackSelector;\n    const textTrack =\n      textTracks.find((textTrack) => {\n        if (textTrack.language === language && textTrack.kind === kind) {\n          textTrack.mode = 'showing';\n        }\n\n        return textTrack.mode === 'showing';\n      }) ||\n      textTracks.find((textTrack) => {\n        if (textTrack.language === language) {\n          textTrack.mode = 'showing';\n        }\n\n        return textTrack.mode === 'showing';\n      });\n\n    return textTrack;\n  }\n}\n\n/**\n * @type {Player}\n */\n// Overrides the default video.js player component\nexport default videojs.registerComponent('player', Player);\n","import { version } from '../package.json';\nimport videojs from 'video.js';\nimport 'videojs-contrib-eme';\nimport './components/player.js';\n\n/**\n * Pillarbox is an alias for the video.js namespace with additional options.\n *\n * @namespace\n * @see https://docs.videojs.com/module-videojs-videojs\n * @type {videojs}\n */\nconst pillarbox = videojs;\n\npillarbox.VERSION = {\n  pillarbox: version,\n  videojs: videojs.VERSION,\n  [videojs.VhsSourceHandler.name]: videojs.VhsSourceHandler.VERSION,\n  eme: videojs.getPlugin('eme').VERSION,\n};\n\n/**\n * Enable smooth seeking for Pillarbox.\n *\n * @see [Video.js enableSmoothSeeking Option]{@link https://videojs.com/guides/options/#enablesmoothseeking}\n * @type {boolean}\n * @default true\n */\npillarbox.options.enableSmoothSeeking = true;\n/**\n * Configuration options for HTML5 settings in Pillarbox.\n *\n * @see [VHS useForcedSubtitles Option]{@link https://github.com/videojs/http-streaming/blob/main/README.md#useforcedsubtitles}\n * @type {Object}\n * @property {Object} vhs - Configuration for the Video.js HTTP Streaming.\n * @property {boolean} useForcedSubtitles - Enables the player to display forced subtitles by default.\n * Forced subtitles are pieces of information intended for display when no other text representation\n * is selected. They are used to clarify dialogue, provide alternate languages, display texted graphics,\n * or present location/person IDs that are not otherwise covered in the dubbed/localized audio.\n */\npillarbox.options.html5 = {\n  vhs: { useForcedSubtitles: true }\n};\n/**\n * Configuration for the live tracker.\n *\n * @see [Video.js liveTracker Option]{@link https://videojs.com/guides/options/#livetrackertrackingthreshold}\n * @type {Object}\n * @property {number} trackingThreshold - A threshold that controls when the liveui should be shown.\n * @property {number} liveTolerance - An option that controls how far from the seekable end should be considered live playback.\n */\npillarbox.options.liveTracker = {\n  trackingThreshold: 120,\n  liveTolerance: 15,\n};\n/**\n * Allows the player to use the live ui that includes:\n *\n * - A progress bar for seeking within the live window\n * - A button that can be clicked to seek to the live edge with a circle indicating if you are at the live edge or not.\n *\n * @see [Video.js liveui Option]{@link https://videojs.com/guides/options/#liveui}\n * @type {boolean}\n */\npillarbox.options.liveui = true;\n/**\n * Indicates that the video is to be played \"inline\", that is within the element's playback area.\n *\n * @see [Video element playsinline attribute]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#playsinline}\n * @type {boolean}\n */\npillarbox.options.playsinline = true;\n/**\n * Configuration for plugins.\n *\n * @see [Video.js Plugins Option]{@link https://videojs.com/guides/options/#plugins}\n * @type {Object}\n * @property {boolean} eme - Enable the EME (Encrypted Media Extensions) plugin.\n */\npillarbox.options.plugins = { eme: true };\n/**\n * Enable responsive mode, this will cause the player to customize itself based on responsive breakpoints.\n *\n * @see [Video.js Responsive Option]{@link https://videojs.com/guides/options/#responsive}\n * @type {boolean}\n */\npillarbox.options.responsive = true;\n/**\n * A placeholder for accessing trackers directly from the player.\n *\n * @type {Object}\n */\npillarbox.options.trackers = {};\n\nexport default pillarbox;\n","/**\n * @class MediaComposition\n */\nclass MediaComposition {\n  /**\n   * Find a chapter by its URN.\n   *\n   * @param {String} urn\n   *\n   * @returns {Object} chapter\n   */\n  findChapterByUrn(urn) {\n    if (this.chapterList) {\n      const [chapter] = this.chapterList.filter(\n        (element) => element.urn === urn\n      );\n\n      return chapter;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Return a segment from main chapter following segmentUrn in mediaComposition.\n   *\n   * @returns {Object|undefined} main segment\n   */\n  findMainSegment() {\n    if (!this.segmentUrn) {\n      return undefined;\n    }\n\n    const segmentList = this.getMainSegments();\n    const [segment] = segmentList.filter(\n      (element) => element.urn === this.segmentUrn\n    );\n\n    return segment;\n  }\n\n  /**\n   * Find resource list by URN.\n   *\n   * @param {String} urn\n   * @returns {Array|undefined} of resources\n   */\n  findResourceListByUrn(urn) {\n    const chapterByUrn = this.findChapterByUrn(urn);\n\n    if (chapterByUrn) {\n      return chapterByUrn.resourceList || [];\n    }\n\n    return undefined;\n  }\n\n  /**\n   * A list of chapters.\n   *\n   * @returns {Array} of chapters\n   */\n  getChapters() {\n    return this.chapterList;\n  }\n\n  /**\n   * Filter external text tracks that are already available internally.\n   *\n   * __Rules:__\n   * 1. TTML format is filtered\n   *\n   * 2. If both are empty that means only internal text tracks will be displayed\n   * to the user as they are automatically loaded by the player.\n   *\n   * 3. If subtitleInformationList is missing from the MediaComposition and subtitleList\n   * is available but the media contains internal text tracks that are also available internally.\n   * It will result on a duplication client side.\n   *\n   * 4. If subtitleList and subtitleInformationList a merge between both will be operated,\n   * removing the external text tracks already available internally.\n   *\n   *\n   * @returns {Array} external text tracks\n   */\n  getFilteredExternalSubtitles() {\n    const { subtitleList } = this.getMainChapter();\n    const [{ subtitleInformationList } = {}] = this.getResourceList().filter(\n      ({ subtitleInformationList }) => subtitleInformationList\n    );\n    const onlyHasExternalSubtitles = subtitleList && !subtitleInformationList;\n\n    if (!subtitleList) {\n      return [];\n    }\n\n    // TTML format is not supported\n    const subtitles = subtitleList.filter(\n      (subtitle) => subtitle.format !== 'TTML'\n    );\n\n    if (onlyHasExternalSubtitles) {\n      return subtitles;\n    }\n\n    return subtitles.filter((subtitle) => {\n      const addSubtitle = !subtitleInformationList.find(\n        (subtitleInformation) =>\n          subtitleInformation.locale === subtitle.locale &&\n          subtitle.type === subtitleInformation.type\n      );\n\n      return addSubtitle;\n    });\n  }\n\n  /**\n   * Block reason for main chapter. This also uses current date for STARTDATE.\n   *\n   * @see BlockingReason\n   *\n   * @returns {undefined|String} undefined if main chapter is not blocked\n   */\n  getMainBlockReason() {\n    const mainChapter = this.getMainChapter();\n\n    if (!mainChapter) {\n      return undefined;\n    }\n\n    let { blockReason } = mainChapter;\n\n    if (!blockReason && new Date() < this.getMainValidFromDate()) {\n      blockReason = 'STARTDATE';\n    }\n\n    return blockReason;\n  }\n\n  /**\n   * Get the mediaComposition's main chapter.\n   *\n   * @returns {Object}\n   */\n  getMainChapter() {\n    if (!this.mainChapter) {\n      this.mainChapter = this.findChapterByUrn(this.chapterUrn);\n    }\n\n    if (!this.mainChapter && this.chapterList && this.chapterList.length > 0) {\n      [this.mainChapter] = this.chapterList;\n    }\n\n    return this.mainChapter;\n  }\n\n  /**\n   * Get the main chapter's image URL decorated with default width and format.\n   *\n   * @returns {String|undefined} image URL\n   */\n  getMainChapterImageUrl() {\n    const mainChapter = this.getMainChapter();\n\n    if (!mainChapter || !mainChapter.imageUrl) {\n      return undefined;\n    }\n\n    return mainChapter.imageUrl;\n  }\n\n  /**\n   * Get main resources.\n   *\n   * @returns {Array} array of sources\n   */\n  getMainResources() {\n    const resourceList = this.getResourceList();\n\n    if (!resourceList || !resourceList.length) {\n      return undefined;\n    }\n\n    return resourceList.map((resource) => ({\n      analyticsData: this.getMergedAnalyticsData(resource.analyticsData),\n      analyticsMetadata: this.getMergedAnalyticsMetadata(\n        resource.analyticsMetadata\n      ),\n      blockReason: this.getMainChapter().blockReason,\n      vendor: this.getMainChapter().vendor,\n      drmList: resource.drmList,\n      dvr: resource.dvr,\n      eventData: this.getMainChapter().eventData,\n      id: this.getMainChapter().id,\n      imageCopyright: this.getMainChapter().imageCopyright,\n      live: resource.live,\n      mediaType: this.getMainChapter().mediaType,\n      mimeType: resource.mimeType,\n      presentation: resource.presentation,\n      quality: resource.quality,\n      streaming: resource.streaming,\n      streamOffset: resource.streamOffset,\n      tokenType: resource.tokenType,\n      url: resource.url,\n    }));\n  }\n\n  /**\n   * Get segments of the main chapter ordered by markIn.\n   *\n   * @returns {Array} of segments\n   */\n  getMainSegments() {\n    const mainChapter = this.getMainChapter();\n\n    if (!this.mainSegments && mainChapter && mainChapter.segmentList) {\n      this.mainSegments = mainChapter.segmentList;\n    }\n\n    return this.mainSegments || [];\n  }\n\n  /**\n   * Compute a date from which this content is valid. Always return a date object.\n   *\n   * @returns {Date} date specified in media composition or EPOCH when no date present.\n   */\n  getMainValidFromDate() {\n    const mainChapter = this.getMainChapter();\n\n    if (!mainChapter) {\n      return new Date(0);\n    }\n\n    const { validFrom } = mainChapter;\n\n    if (validFrom) {\n      return new Date(validFrom);\n    }\n  }\n\n  /**\n   * Get merged analytics data.\n   *\n   * @returns {Object}\n   */\n  getMergedAnalyticsData(analyticsData) {\n    return {\n      ...this.analyticsData,\n      ...this.getMainChapter().analyticsData,\n      ...analyticsData,\n    };\n  }\n\n  /**\n   * Get merged analytics metadata.\n   *\n   * @returns {Object}\n   */\n  getMergedAnalyticsMetadata(analyticsMetadata) {\n    return {\n      ...this.analyticsMetadata,\n      ...this.getMainChapter().analyticsMetadata,\n      ...analyticsMetadata,\n    };\n  }\n\n  /**\n   * Get the chapter's resource list\n   * @returns {Array} of resources\n   */\n  getResourceList() {\n    const { resourceList } = this.getMainChapter();\n\n    return resourceList || [];\n  }\n}\n\nexport default MediaComposition;\n","import MediaComposition from '../model/MediaComposition.js';\n\n/**\n * @ignore\n */\nclass DataProvider {\n  constructor(hostName = 'il.srgssr.ch') {\n    this.setIlHost(hostName);\n  }\n\n  setIlHost(hostName) {\n    this.baseUrl = `${hostName}/integrationlayer/2.1/`;\n  }\n\n  /**\n   * Get media composition by URN.\n   *\n   * @param {String} urn URN of the media composition.\n   * @param {Boolean} [onlyChapters=true] Whether to retrieve only chapters or not.\n   *\n   * @returns {Promise<{mediaComposition: MediaComposition}>} Promise that resolves with the `mediaComposition` object.\n   * @throws {Promise<Response>} If the response is not ok.\n   */\n  async getMediaCompositionByUrn(urn, onlyChapters = true) {\n    const url = `https://${this.baseUrl}mediaComposition/byUrn/${urn}?onlyChapters=${onlyChapters}&vector=portalplay`;\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw response;\n    }\n\n    const data = await response.json();\n    const mediaComposition = Object.assign(new MediaComposition(), data, {\n      onlyChapters,\n    });\n\n    return {\n      mediaComposition,\n    };\n  }\n}\n\nexport default DataProvider;\n","const SCALE = {\n  WIDTH_240: '240',\n  WIDTH_320: '320',\n  WIDTH_480: '480',\n  WIDTH_960: '960',\n  WIDTH_1920: '1920',\n};\n\nconst FORMAT = {\n  JPG: 'jpg',\n  WEBP: 'webp',\n  PNG: 'png',\n};\n\nconst IMAGE_SERVICE_URL = 'https://il.srgssr.ch/images/';\n\n/**\n * @class Image\n */\nclass Image {\n  /**\n   * Generates the image scaling URL.\n   *\n   * @property {Object} image is the object representation of an image.\n   * @property {String} [image.url] is the image URL.\n   * @property {String} [image.width=960] is the width of the image, default value 960.\n   * @property {String} [image.format=jpg] is the format of the image, default value jpg.\n   * @property {String} [imageServiceUrl] Url of the image service that needs to comply with the specification defined by the IL.\n   *\n   * @see https://confluence.srg.beecollaboration.com/pages/viewpage.action?spaceKey=SRGPLAY&title=Project+-+Image+Service\n   *\n   * @returns {String|undefined} the image scaling URL.\n   */\n  static scale(\n    { url, width = SCALE.WIDTH_960, format = FORMAT.JPG } = {},\n    imageServiceUrl = IMAGE_SERVICE_URL\n  ) {\n    if (!url) return;\n\n    const scaleUrl = new URL(imageServiceUrl);\n\n    scaleUrl.searchParams.set('imageUrl', url);\n    scaleUrl.searchParams.set('format', format);\n    scaleUrl.searchParams.set('width', width);\n\n    return decodeURIComponent(scaleUrl.href);\n  }\n\n  static get JPG() {\n    return FORMAT.JPG;\n  }\n\n  static get PNG() {\n    return FORMAT.PNG;\n  }\n\n  static get WEBP() {\n    return FORMAT.WEBP;\n  }\n\n  static get WIDTH_240() {\n    return SCALE.WIDTH_240;\n  }\n\n  static get WIDTH_320() {\n    return SCALE.WIDTH_320;\n  }\n\n  static get WIDTH_480() {\n    return SCALE.WIDTH_480;\n  }\n\n  static get WIDTH_960() {\n    return SCALE.WIDTH_960;\n  }\n\n  static get WIDTH_1920() {\n    return SCALE.WIDTH_1920;\n  }\n}\n\nexport default Image;\n","const DRM_VENDORS = {\n  WIDEVINE: 'com.widevine.alpha',\n  FAIRPLAY: 'com.apple.fps.1_0',\n  PLAYREADY: 'com.microsoft.playready',\n};\n\n/**\n * @class Drm\n */\nclass Drm {\n  /**\n   * Build the keySystems object according to the DRM vendor.\n   *\n   * @param {Array.<Object>} drmList\n   *\n   * @returns {Object}\n   */\n  static buildKeySystems(drmList = []) {\n    const keySystems = {};\n\n    drmList.forEach((drmVendor) => {\n      const type = Drm.vendors[drmVendor.type];\n\n      if (Drm.vendors.FAIRPLAY === type) {\n        const { certificateUrl: certificateUri, licenseUrl: licenseUri } =\n          drmVendor;\n\n        keySystems[type] = {\n          certificateUri,\n          licenseUri,\n        };\n      } else {\n        keySystems[type] = drmVendor.licenseUrl;\n      }\n    });\n\n    return {\n      keySystems,\n    };\n  }\n\n  /**\n   * Check if some of the resources have DRM.\n   */\n  static hasDrm(resources) {\n    return resources.some(({ drmList }) => drmList && drmList.length > 0);\n  }\n\n  /**\n   * Get DRM vendors.\n   */\n  static get vendors() {\n    return DRM_VENDORS;\n  }\n}\n\nexport default Drm;\n","const TOKEN_TYPES = {\n  AKAMAI: 'AKAMAI',\n  NONE: 'NONE',\n};\n\n/**\n * @class AkamaiTokenService\n */\nclass AkamaiTokenService {\n  /**\n   * Get the acl path.\n   *\n   * @param {URL} streamUrl\n   *\n   * @returns {String}\n   */\n  static aclPath(streamUrl) {\n    const path = streamUrl.pathname;\n\n    return `${path.substring(0, path.lastIndexOf('/') + 1)}*`;\n  }\n\n  /**\n   * AKAMAI\n   *\n   * @type {String}\n   */\n  static get AKAMAI() {\n    return TOKEN_TYPES.AKAMAI;\n  }\n\n  /**\n   * Check if the resources are protected by an Akamai token.\n   * Keep in mind, as we are using the some function,\n   * if the resources have at least one resource\n   * protected by a token it returns true!\n   *\n   * @param {Array.<Object>} resources\n   *\n   * @returns {Boolean}\n   */\n  static hasToken(resources) {\n    return resources.some((resource) =>\n      AkamaiTokenService.isAkamai(resource.tokenType));\n  }\n\n  /**\n   * Check if the token type is AKAMAI.\n   *\n   * @param {String} tokentype\n   *\n   * @returns {Boolean}\n   */\n  static isAkamai(tokentype) {\n    return TOKEN_TYPES.AKAMAI === tokentype;\n  }\n\n  /**\n   * Check if the token type is NONE.\n   *\n   * @param {String} tokentype\n   *\n   * @returns {Boolean}\n   */\n  static isNone(tokentype) {\n    return TOKEN_TYPES.NONE === tokentype;\n  }\n\n  /**\n   * NONE\n   *\n   * @type {String}\n   */\n  static get NONE() {\n    return TOKEN_TYPES.NONE;\n  }\n\n  /**\n   * Generate the stream URL with the akamai token.\n   *\n   * @param {String} source\n   * @param {String} tokenServerUrl\n   *\n   * @returns {Promise.<Object>}\n   */\n  static tokenize(source, tokenServerUrl) {\n    const streamUrlToTokenize = new URL(`${source.url}`);\n    const acl = AkamaiTokenService.aclPath(streamUrlToTokenize);\n    const url = `${tokenServerUrl}${encodeURIComponent(acl)}`;\n\n    return fetch(url)\n      .then((response) => {\n        if (response.ok) {\n          return response.json();\n        }\n\n        return Promise.reject({\n          status: response.status,\n          statusText: response.statusText,\n        });\n      })\n      .then(({ token: { authparams }}) => {\n        const akamaiAuthParams = new URLSearchParams(authparams);\n\n        akamaiAuthParams.forEach((v, k) =>\n          streamUrlToTokenize.searchParams.set(k, v));\n\n        return Object.assign({}, source, {\n          url: streamUrlToTokenize.toString(),\n        });\n      })\n      .catch((reason) => {\n        return Promise.reject(reason);\n      });\n  }\n\n  /**\n   * Generate a token for each source\n   *\n   * @param {Array} sources\n   * @param {String} tokenServerUrl\n   *\n   * @returns {Promise.<Array.<Object>>}\n   */\n  static tokenizeSources(\n    sources,\n    tokenServerUrl = 'https://tp.srgssr.ch/akahd/token?acl='\n  ) {\n    const tokenizedSources = [];\n\n    sources.forEach((source) => {\n      const tokenizedSource = AkamaiTokenService.tokenize(\n        source,\n        tokenServerUrl\n      );\n\n      tokenizedSources.push(tokenizedSource);\n    });\n\n    return Promise.all(tokenizedSources)\n      .then((values) => values)\n      .catch((reason) => Promise.reject(reason));\n  }\n}\n\nexport default AkamaiTokenService;\n","/**\n * Exhaustive list of player events.\n *\n * See below the documentation related to the media events\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement#events\n *\n * @namespace {Object} PlayerEvents\n */\n\n/**\n * Triggered when the media can start playing.\n *\n * @event PlayerEvents#CAN_PLAY\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplay_event\n */\nexport const CAN_PLAY = 'canplay';\n\n/**\n * Triggered when the media can be played through to the end without buffering.\n *\n * @event PlayerEvents#CAN_PLAY_THROUGH\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplaythrough_event\n */\nexport const CAN_PLAY_THROUGH = 'canplaythrough';\n\n/**\n * Triggered when the duration of the media changes.\n *\n * @event PlayerEvents#DURATION_CHANGE\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/durationchange_event\n */\nexport const DURATION_CHANGE = 'durationchange';\n\n/**\n * Triggered when the media element is emptied (e.g., reset as part of the seeking process).\n *\n * @event PlayerEvents#EMPTIED\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/emptied_event\n */\nexport const EMPTIED = 'emptied';\n\n/**\n * Triggered when the media playback has ended.\n *\n * @event PlayerEvents#ENDED\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/ended_event\n */\nexport const ENDED = 'ended';\n\n/**\n * Triggered when an error occurs during media playback.\n *\n * @event PlayerEvents#ERROR\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/error_event\n */\nexport const ERROR = 'error';\n\n/**\n * Triggered when the media data has been loaded.\n *\n * @event PlayerEvents#LOADED_DATA\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadeddata_event\n */\nexport const LOADED_DATA = 'loadeddata';\n\n/**\n * Triggered when metadata for the media has been loaded.\n *\n * @event PlayerEvents#LOADED_METADATA\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event\n */\nexport const LOADED_METADATA = 'loadedmetadata';\n\n/**\n * Triggered when the browser starts looking for media data.\n *\n * @event PlayerEvents#LOAD_START\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadstart_event\n */\nexport const LOAD_START = 'loadstart';\n\n/**\n * Triggered when the media playback is paused.\n *\n * @event PlayerEvents#PAUSE\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause_event\n */\nexport const PAUSE = 'pause';\n\n/**\n * Triggered when the media playback is resumed or started.\n *\n * @event PlayerEvents#PLAY\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play_event\n */\nexport const PLAY = 'play';\n\n/**\n * Triggered when the media playback is in progress.\n *\n * @event PlayerEvents#PLAYING\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/playing_event\n */\nexport const PLAYING = 'playing';\n\n/**\n * Triggered as the media is being loaded.\n *\n * @event PlayerEvents#PROGRESS\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/progress_event\n */\nexport const PROGRESS = 'progress';\n\n/**\n * Triggered when the playback rate changes.\n *\n * @event PlayerEvents#RATE_CHANGE\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/ratechange_event\n */\nexport const RATE_CHANGE = 'ratechange';\n\n/**\n * Triggered when a seek operation is completed.\n *\n * @event PlayerEvents#SEEKED\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/seeked_event\n */\nexport const SEEKED = 'seeked';\n\n/**\n * Triggered when a seek operation is in progress.\n *\n * @event PlayerEvents#SEEKING\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/seeking_event\n */\nexport const SEEKING = 'seeking';\n\n/**\n * Triggered when the media playback is stalled.\n *\n * @event PlayerEvents#STALLED\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/stalled_event\n */\nexport const STALLED = 'stalled';\n\n/**\n * Triggered when media loading is suspended.\n *\n * @event PlayerEvents#SUSPEND\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/suspend_event\n */\nexport const SUSPEND = 'suspend';\n\n/**\n * Triggered when the current playback position is updated.\n *\n * @event PlayerEvents#TIME_UPDATE\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/timeupdate_event\n */\nexport const TIME_UPDATE = 'timeupdate';\n\n/**\n * Triggered when the volume is changed.\n *\n * @event PlayerEvents#VOLUME_CHANGE\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/volumechange_event\n */\nexport const VOLUME_CHANGE = 'volumechange';\n\n/**\n * Triggered when the media playback is waiting for data.\n *\n * @event PlayerEvents#WAITING\n * @type {string}\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/waiting_event\n */\nexport const WAITING = 'waiting';\n","import * as PlayerEvents from '../utils/PlayerEvents.js';\nimport Pillarbox from '../pillarbox.js';\n/* eslint max-lines-per-function: [\"error\", 200] */\n/* eslint max-statements: [\"error\", 20]*/\n/* eslint complexity: [\"error\", 10]*/\n/**\n * SRG analytics\n * @class SRGAnalytics\n * @ignore\n *\n * ### Script URL\n * JS script : https://colibri-js.akamaized.net/penguin/tc_SRGGD_11.js\n *\n * ### Official documentation\n * Variables list\n * @see https://confluence.srg.beecollaboration.com/display/INTFORSCHUNG/Datalayer+for+media+players\n *\n * Standard event sequences\n * @see https://confluence.srg.beecollaboration.com/display/INTFORSCHUNG/standard+streaming+events%3A+sequence+of+events+for+media+player+actions\n *\n * Review of Standard Media Actions\n * @see https://confluence.srg.beecollaboration.com/display/INTFORSCHUNG/Implementation+Concept+-+draft\n *\n * ComScore Implementation Guide\n * @see https://www.dropbox.com/sh/cdwuikq0abxi21m/AABmSyXYKUTWSAwRZgQA9Ujna/JavaScript%20Latest%20Version?dl=0&preview=Comscore_Library-JavaScript-Streaming_Tag-Implementation_Guide-International.pdf&subfolder_nav_tracking=1\n *\n * ### Variables list\n * - 'event_id', // init | play | stop | pos | pause | seek | uptime | eof\n * - 'event_timestamp', // Seems to be generated automatically from the documentation, but the TP overrides it\n * - 'event_name', // NA TP seems to not sending this variable\n * - 'event_source', // NA TP seems to not sending this variable\n * - 'event_name', // NA TP seems to not sending this variable\n * - 'event_value', // NA TP seems to not sending this variable\n * - 'navigation_environment', // prod | preprod\n * - 'media_subtitles_on', // string true | false\n * - 'media_timeshift', // need better description\n * - 'media_quality', // SD | HD ?\n * - 'media_bandwidth', // NA for the web, 64000\n * - 'media_volume', // from 0 to 100\n * - 'media_embedding_url', //\n * - 'media_player_name', // videojs | letterbox-web ?\n * - 'media_chromecast_selected', // boolean true | false\n * - 'media_player_version', // player's version\n * - 'media_player_display', // is the player mode, on the TP : inline, embed etc..\n * - 'media_audio_track', // NA\n * - 'media_position_real', // NA\n * - 'media_time_spent', // NA\n * - 'device_id', // NA\n * - 'user_id_log_in', // NA only RTS has log in today\n * - 'media_thumbnail', // Not required by the spec but sended by the TP\n * - 'media_bu_distributer', // Not required by the spec but sended by the TP\n *\n *\n * ### Sequence stories\n *\n * __Story 1 (AoD/VOD-basics)__: A VoD is played. The user does not interact with the player. The VoD plays to its end.\n *\n * Hints:\n * - Media sessions always start with PLAY. They end with STOP or EOF (or with PAUSE or last POS)\n * - POS is sent ever 30s\n *\n *\n * __Story 2 (livestream-basics A)__: A Livestream is played. The user does not interact with the player. After 61 seconds, playback is paused.\n *\n * Hints:\n * - Media sessions always start with PLAY. They end with STOP (or, worse for data quailty, with PAUSE or last POS/UPTIME)\n * - UPTIME is sent only for livestreams\n * - POS is sent ever 30s, UPTIME every 60s with inital UPTIME after 30s.\n * - This is the interval: 30s: POS + UPTIME; 60s: POS; 90s: POS + UPTIME; ...\n *\n *\n * __Story 3 (Seeking a VoD/AoD)__: A VoD is played. User seeks in the VoD/AoD.\n *\n * Hints:\n * - Once the Media Player slider is released (seek is over), another action to finish up the seeking is initiated. Typically this is PLAY. For that second PLAY, the media position has altered.\n *\n *\n * __Story 4 (Seeking a livestream)__: A Livestream is played. User goes back in the livestream.\n *\n * Hints:\n * - Once the Media Player slider is released (seek is over), another action to finish up the seeking is initiated. Typically this is PLAY.  For that second PLAY, the a new variable, media_timeshift is passed.\n * - For livestreams media_position is always the \"time passed on your watch\" - regardless of the SEEK event. So, if 1 second after PLAY the slider is moved  back 600 seconds, then:\n *  1. The the value of media_timeshift is '600'.\n *  2. The value of media_position is '1'.\n */\nclass SRGAnalytics {\n  constructor(\n    player,\n    {\n      debug = false,\n      environment = 'prod',\n      playerVersion = 'none',\n      tagCommanderScriptURL = '//colibri-js.akamaized.net/penguin/tc_SRGGD_11.js',\n    } = {}\n  ) {\n    this.isDebugEnabled = debug;\n    this.elapsedPlaybackTime = 0;\n    this.environment = environment;\n    this.hasStarted = false;\n    this.heartBeatIntervalId = undefined;\n    /* Set to true when 'init' event is sent or queued. */\n    this.initialized = false;\n    this.isSeeking = false;\n    this.isWaiting = false;\n    this.mediaSession = 0;\n    this.pendingQueue = [];\n    this.pendingTagCommanderReload = false;\n    this.player = player;\n    this.playerVersion = playerVersion;\n    this.srcMediaData = undefined;\n    this.startPlaybackSession = 0;\n    this.tagCommanderScriptURL = tagCommanderScriptURL;\n    this.trackedCurrentTime = 0;\n    this.uptimeIntervalId = undefined;\n\n    this.initScript();\n    this.initListeners();\n  }\n\n  /**\n   * Sent when the window, the document and its resources are about to be unloaded.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event\n   */\n  beforeunload() {\n    this.notify('stop');\n  }\n\n  /**\n   * Clear timers used to send uptime and heartbeat.\n   */\n  clearTimers() {\n    clearInterval(this.heartBeatIntervalId);\n    clearInterval(this.uptimeIntervalId);\n    clearTimeout(this.uptimeTimeoutId);\n  }\n\n  /**\n   * Get the tracked current time in seconds.\n   *\n   * @returns {Number} current time in seconds\n   */\n  currentTime() {\n    // see PLAYRTS-2771\n    return Math.round(this.trackedCurrentTime);\n  }\n\n  /**\n   * Get or set debug mode.\n   *\n   * @returns {Boolean|undefined}\n   */\n  debug(enabled) {\n    if (enabled === undefined) {\n      return this.isDebugEnabled || this.player.debug();\n    }\n\n    this.isDebugEnabled = Boolean(enabled);\n  }\n\n  /**\n   * Destroy all properties and setIntervals to avoid mixing media sessions.\n   */\n  destroy() {\n    this.clearTimers();\n\n    if (!window.tc_vars) {\n      window.tc_vars = {};\n    }\n    this.elapsedPlaybackTime = 0;\n    this.hasStarted = false;\n    this.heartBeatIntervalId = undefined;\n    this.initialized = false;\n    this.isWaiting = false;\n    this.mediaSession = 0;\n    this.pendingQueue = [];\n    this.srcMediaData = undefined;\n    this.startPlaybackSession = 0;\n    this.trackedCurrentTime = 0;\n    this.uptimeIntervalId = undefined;\n  }\n\n  /**\n   * Dispose all listeners used to send analytics data to TagCommander.\n   *\n   * Calls `beforeunload` to send a notify stop.\n   * Clear intervals and timeouts.\n   *\n   * __Used events__\n   * - beforeunload\n   * - emptied\n   * - ended\n   * - loadstart\n   * - loadeddata\n   * - play\n   * - pause\n   * - timeupdate\n   */\n  dispose() {\n    this.beforeunload();\n    this.clearTimers();\n\n    window.removeEventListener('beforeunload', this.beforeunloadListener);\n\n    this.player.off(PlayerEvents.EMPTIED, this.emptiedListener);\n    this.player.off(PlayerEvents.ENDED, this.endedListener);\n    this.player.off(PlayerEvents.LOAD_START, this.loadstartListener);\n    this.player.off(PlayerEvents.LOADED_DATA, this.loadeddataListener);\n    this.player.off(PlayerEvents.PLAYING, this.playListener);\n    this.player.off(PlayerEvents.PAUSE, this.pauseListener);\n    this.player.off(PlayerEvents.RATE_CHANGE, this.rateChangeListener);\n    this.player.off(PlayerEvents.SEEKING, this.seekingListener);\n    this.player.off(PlayerEvents.TIME_UPDATE, this.timeUpdateListener);\n    this.player.off(PlayerEvents.WAITING, this.waitingListener);\n  }\n\n  /**\n   * Sent before a new media is loading.\n   * - Destroy all properties.\n   * - Send a notify stop if the media is not ended and new media is about to be loaded.\n   */\n  emptied() {\n    if (!this.player.ended()) {\n      this.notify('stop');\n    }\n  }\n\n  /**\n   * Sent when playback completes.\n   *\n   * @see https://docs.videojs.com/player#event:ended\n   */\n  ended() {\n    this.notify('eof');\n\n    this.mediaSession = 0;\n\n    this.clearTimers();\n  }\n\n  /**\n   * Flush the queued events when tc event script is loaded.\n   */\n  flush() {\n    if (this.isTrackerDisabled()) return;\n\n    if (this.pendingTagCommanderReload && window.tC) {\n      window.tC.container.reload();\n      this.pendingTagCommanderReload = false;\n    }\n\n    if (window.tc_events_11 && this.pendingQueue.length > 0) {\n      this.pendingQueue.forEach((notification) => {\n        window.tc_events_11(\n          this.player.el(),\n          notification.action,\n          notification.labels\n        );\n      });\n\n      this.pendingQueue = [];\n    }\n  }\n\n  /**\n   * Get the language of the current audio track.\n   *\n   * @returns {String} empty string or uppercase language.\n   */\n  getCurrentAudioTrack() {\n    const currentTrack = Array.from(this.player.audioTracks()).find(\n      (track) => track.enabled\n    );\n    let language = 'und';\n\n    if (currentTrack && !!currentTrack.language) {\n      // eslint-disable-next-line prefer-destructuring\n      language = currentTrack.language;\n    }\n\n    return currentTrack ? language.toUpperCase() : '';\n  }\n\n  /**\n   * Get the language of the current text track.\n   *\n   * @returns {String} empty string or uppercase language.\n   */\n  getCurrentTextTrack() {\n    const currentTrack = this.player.textTrack();\n    let language = 'und';\n\n    if (currentTrack && !!currentTrack.language) {\n      // eslint-disable-next-line prefer-destructuring\n      language = currentTrack.language;\n    }\n\n    return currentTrack ? language.toUpperCase() : '';\n  }\n\n  /**\n   * Get the position inside the dvr window where the 0 represents the live edge\n   *\n   * @return {Number} 0 or the position in milliseconds\n   */\n  getDvrWindowPosition() {\n    const { liveTracker } = this.player;\n    const ct = (this.currentTime() - liveTracker.seekableStart()) | 0;\n    const position = liveTracker.liveWindow() - ct;\n\n    return position < 0 || position === Infinity ? 0 : position * 1000;\n  }\n\n  /**\n   * Get the size of the live DVR window in milliseconds.\n   *\n   * @return {Number} DVR window size in milliseconds\n   */\n  getDvrWindowSize() {\n    const isInfinity = this.player.liveTracker.liveWindow() === Infinity;\n    const windowSize = this.player.liveTracker.liveWindow() * 1000;\n\n    return isInfinity ? 0 : windowSize;\n  }\n\n  /**\n   * Get the elapsed playback time in seconds.\n   *\n   * @returns {Number} elapsed time in seconds\n   */\n  getElapsedPlaybackTime() {\n    if (this.startPlaybackSession) {\n      return this.getElapsedPlayingTime();\n    }\n\n    return this.elapsedPlaybackTime;\n  }\n\n  /**\n   * Get the elapsed playing time in seconds.\n   *\n   * @returns {Number} elapsed time in seconds\n   */\n  getElapsedPlayingTime() {\n    const playingSession = (SRGAnalytics.now() - this.startPlaybackSession) | 0;\n\n    return this.elapsedPlaybackTime + playingSession;\n  }\n\n  /**\n   * Set all event labels to be sent to TagCommander. The event labels are updated whenever a new event occurs.\n   *\n   * @param {String} eventName init | play | stop | pos | pause | seek | uptime | eof\n   *\n   * @returns {Object} JSON to be sent to TagCommander\n   */\n  getEventLabels(eventName) {\n    const labels = {\n      event_id: eventName,\n      event_timestamp: SRGAnalytics.now(),\n      media_dvr_window_length: 0,\n      media_dvr_window_offset: 0,\n      media_is_dvr: false,\n      media_is_live: false,\n      media_mute: this.player.muted() ? '1' : '0',\n      media_playback_rate: this.player.playbackRate(),\n      media_position: this.currentTime(),\n      media_quality: this.srcMediaData.mediaData.quality,\n      // TODO use media_is_dvr, media_is_live to define peach media_stream_type\n      media_subtitles_on: this.isTextTrackEnabled(),\n      media_volume: (this.player.volume() * 100).toFixed(0),\n      navigation_environment: this.environment,\n    };\n\n    if (this.isAudioTrackEnabled()) {\n      labels.media_audio_track = this.getCurrentAudioTrack();\n    }\n\n    if (this.isTextTrackEnabled()) {\n      labels.media_subtitle_selection = this.getCurrentTextTrack();\n    }\n\n    // DVR or Live related labels\n    if (!this.isMediaOnDemand()) {\n      labels.media_is_live = true;\n      labels.media_position = this.getElapsedPlaybackTime();\n    }\n\n    // DVR related labels\n    if (this.isMediaDvr()) {\n      labels.media_dvr_window_offset = this.getDvrWindowPosition() | 0;\n      labels.media_dvr_window_length = this.getDvrWindowSize() | 0;\n\n      labels.media_is_dvr = true;\n\n      labels.media_timeshift = [PlayerEvents.PLAY, PlayerEvents.PAUSE].includes(\n        eventName\n      )\n        ? this.timeShifted()\n        : 0;\n    }\n\n    return labels;\n  }\n\n  /**\n   * Set all internal labels to be sent to TagCommander. Internal labels are assigned once at initialisation time.\n   */\n  getInternalLabels() {\n    const data = {\n      media_bu_distributer: this.srcMediaData.mediaData.vendor,\n      media_chromecast_selected: Boolean(this.player.tech(true).isCasting),\n      media_embedding_url: document.referrer,\n      media_player_display: 'default', // TODO implement if it still relevant\n      media_player_name: 'pillarbox-web', // TODO add a property playerName in the constructor with a default value ?\n      media_player_version: this.playerVersion,\n      media_url: this.srcMediaData.src,\n    };\n    const analyticsMetadata =\n      this.srcMediaData.mediaData.analyticsMetadata || {};\n\n    window.tc_vars = Object.assign({}, window.tc_vars, data, analyticsMetadata);\n  }\n\n  /**\n   * Heart beat, current position of a AoD/VoD (every 30s).\n   *\n   * @description The action pos should be sent regularly every 30 seconds.\n   * It is used for tracking the viewed chapters of a video and the last position of the video, in case the user ends the video by closing the browser tab/window.\n   *\n   * - pos should be sent when the media player is in \"play mode\".\n   * - once the video is paused or stopped, the timer for sending these actions must be stopped.\n   *\n   * @see https://confluence.srg.beecollaboration.com/display/INTFORSCHUNG/standard+streaming+events%3A+sequence+of+events+for+media+player+actions#standardstreamingevents:sequenceofeventsformediaplayeractions-mandatoryplayerevents\n   */\n  heartBeat() {\n    this.heartBeatIntervalId = setInterval(() => {\n      // Send only when playing\n      if (!this.player.paused()) {\n        this.notify('pos');\n      }\n    }, 30000);\n  }\n\n  /**\n   * Initialize callbacks used to send analytics data to TagCommander.\n   *\n   * __Used events__\n   * - beforeunload\n   * - emptied\n   * - ended\n   * - loadstart\n   * - loadeddata\n   * - play\n   * - pause\n   * - ratechange\n   * - seeking\n   * - timeupdate\n   * - waiting\n   */\n  initCallbacks() {\n    this.beforeunloadListener = this.beforeunload.bind(this);\n    this.emptiedListener = this.emptied.bind(this);\n    this.endedListener = this.ended.bind(this);\n    this.loadstartListener = this.loadstart.bind(this);\n    this.loadeddataListener = this.loadeddata.bind(this);\n    this.playListener = this.play.bind(this);\n    this.pauseListener = this.pause.bind(this);\n    this.rateChangeListener = this.rateChange.bind(this);\n    this.seekingListener = this.seeking.bind(this);\n    this.timeUpdateListener = this.timeUpdate.bind(this);\n    this.waitingListener = this.waiting.bind(this);\n  }\n\n  /**\n   * Initialize all listeners used to send analytics data to TagCommander.\n   *\n   * __Used events__\n   * - beforeunload\n   * - dispose\n   * - emptied\n   * - ended\n   * - loadstart\n   * - loadeddata\n   * - play\n   * - pause\n   * - timeupdate\n   * - waiting\n   */\n  initListeners() {\n    this.initCallbacks();\n\n    window.addEventListener('beforeunload', this.beforeunloadListener);\n\n    this.player.on(PlayerEvents.EMPTIED, this.emptiedListener);\n    this.player.on(PlayerEvents.ENDED, this.endedListener);\n    this.player.on(PlayerEvents.LOAD_START, this.loadstartListener);\n    this.player.on(PlayerEvents.LOADED_DATA, this.loadeddataListener);\n    this.player.on(PlayerEvents.PLAYING, this.playListener);\n    this.player.on(PlayerEvents.PAUSE, this.pauseListener);\n    this.player.on(PlayerEvents.RATE_CHANGE, this.rateChangeListener);\n    this.player.on(PlayerEvents.SEEKING, this.seekingListener);\n    this.player.on(PlayerEvents.TIME_UPDATE, this.timeUpdateListener);\n    this.player.on(PlayerEvents.WAITING, this.waitingListener);\n    this.player.one('dispose', this.dispose.bind(this));\n  }\n\n  /**\n   * Initialize TagCommander script dynamically and add it to the DOM\n   */\n  initScript() {\n    const scriptId = 'tc_script__11';\n\n    if (!document.querySelector(`#${scriptId}`)) {\n      const script = document.createElement('script');\n      const src = this.tagCommanderScriptURL;\n\n      script.defer = true;\n      script.id = scriptId;\n      script.src = src;\n      script.type = 'text/javascript';\n\n      script.onload = (_e) => {\n        this.flush();\n      };\n\n      document.body.appendChild(script);\n    }\n  }\n\n  /**\n   * Check if the audio track is enabled.\n   *\n   * @returns {Boolean} __true__ if enabled __false__ otherwise.\n   */\n  isAudioTrackEnabled() {\n    return !!this.getCurrentAudioTrack();\n  }\n\n  /**\n   * Check if the media is a live with DVR.\n   *\n   * @returns {Boolean} __true__ if it DVR __false__ otherwise.\n   */\n  isMediaDvr() {\n    const { trackingThreshold } = this.player.liveTracker.options();\n\n    return (\n      !this.isMediaOnDemand() &&\n      trackingThreshold < this.player.liveTracker.liveWindow()\n    );\n  }\n\n  /**\n   * Check if the media is a live.\n   *\n   * @returns {Boolean} __true__ if live __false__ otherwise.\n   */\n  isMediaLive() {\n    const { trackingThreshold } = this.player.liveTracker.options();\n\n    return (\n      !this.isMediaOnDemand() &&\n      trackingThreshold > this.player.liveTracker.liveWindow()\n    );\n  }\n\n  /**\n   * Check if the media is an on demand.\n   *\n   * @returns {Boolean} __true__ if on demand __false__ otherwise.\n   */\n  isMediaOnDemand() {\n    return Number.isFinite(this.player.duration());\n  }\n\n  /**\n   * Check if the text track is enabled.\n   *\n   * @returns {Boolean} __true__ if enabled __false__ otherwise.\n   */\n  isTextTrackEnabled() {\n    return !!this.getCurrentTextTrack();\n  }\n\n  /**\n   * Check if the tracker is disabled.\n   *\n   * @returns {Boolean} __true__ if disabled __false__ otherwise.\n   */\n  isTrackerDisabled() {\n    if (!this.srcMediaData || !this.srcMediaData.mediaData)\n      return true;\n\n    if (!Array.isArray(this.srcMediaData.disableTrackers)) {\n      return Boolean(this.srcMediaData.disableTrackers);\n    }\n\n    return Boolean(\n      this.srcMediaData.disableTrackers.find(\n        (tracker) => tracker.toLowerCase() === SRGAnalytics.name.toLowerCase()\n      )\n    );\n  }\n\n  /**\n   * Sent when loading of the media begins.\n   *\n   * @see https://docs.videojs.com/player#event:loadstart\n   */\n  loadstart() {\n    this.destroy();\n    this.updateSrcMediaData(this.player.currentSource());\n\n    if (this.isTrackerDisabled()) return;\n\n    this.getInternalLabels();\n    // Set ComScore labels\n    this.reloadTagCommanderContainer();\n\n    this.notify('buffer_start');\n    this.hasStarted = false;\n  }\n\n  /**\n   * The first frame of the media has finished loading.\n   *\n   * @see https://docs.videojs.com/player#event:loadeddata\n   */\n  loadeddata() {\n    this.notify('init');\n    this.initialized = true;\n\n    this.notify('buffer_stop');\n  }\n\n  /**\n   * Event logger that prints the current event, event labels and internal labels in the browser's console.\n   *\n   * @param {String} eventName init | play | stop | pos | pause | seek | uptime | eof\n   * @param {Object} eventMetadata event metadata object\n   * @param {String} severity log | warn | error\n   */\n  log(eventName, eventMetadata, severity = 'log') {\n    if (this.debug()) {\n      // eslint-disable-next-line\n      console[severity](\n        `SRGAnalytics:${eventName}`,\n        eventMetadata,\n        window.tc_vars\n      );\n    }\n  }\n\n  /**\n   * Notify TagCommander all event and internal labels. If tc script is not available it queues all pending events.\n   *\n   * @param {String} eventName init | play | stop | pos | pause | seek | uptime | eof\n   */\n  notify(eventName, eventMetadata) {\n    if (this.isTrackerDisabled()) return;\n\n    try {\n      this.flush();\n    } catch (error) {\n      this.log(eventName, error, 'error');\n    }\n\n    const labels = Object.assign(\n      {},\n      this.getEventLabels(eventName),\n      eventMetadata\n    );\n\n    this.log(eventName, labels);\n\n    try {\n      if (window.tc_events_11) {\n        window.tc_events_11(this.player.el(), eventName, labels);\n      } else {\n        this.pendingQueue.push({\n          action: eventName,\n          labels,\n        });\n      }\n    } catch (error) {\n      this.log(eventName, error, 'error');\n    }\n  }\n\n  /**\n   * Return the current timestamp in seconds.\n   *\n   * @returns {Number} Timestamp in seconds\n   */\n  static now() {\n    return (Date.now() / 1000).toFixed(0);\n  }\n\n  /**\n   * Sent when the playback state is no longer paused, as a result of the play method, or the autoplay attribute.\n   *\n   * @see https://docs.videojs.com/player#event:play\n   */\n  play() {\n    if (!this.hasStarted) this.hasStarted = true;\n\n    if (!this.startPlaybackSession && !this.isMediaOnDemand()) {\n      this.startPlaybackSession = SRGAnalytics.now();\n    }\n\n    if (this.mediaSession === 0) {\n      this.mediaSession = SRGAnalytics.now();\n\n      this.heartBeat();\n      this.uptime();\n    }\n\n    this.timeUpdate();\n    this.notify('play');\n\n    if (this.isSeeking) this.isSeeking = false;\n  }\n\n  /**\n   * Sent when the playback state is changed to paused (paused property is true).\n   * Pause event is sent if :\n   * - The player is not scrubbing\n   * - The stream is not a live only\n   * - The current time is strictly inferior to the duration\n   *\n   * @see https://docs.videojs.com/player#event:pause\n   */\n  pause() {\n    if (!this.isMediaOnDemand()) {\n      this.elapsedPlaybackTime = this.getElapsedPlayingTime();\n      this.startPlaybackSession = 0;\n    }\n\n    if (\n      !this.player.seeking() &&\n      !this.isMediaLive() &&\n      this.player.currentTime() < this.player.duration()\n    ) {\n      this.notify('pause');\n\n      return;\n    }\n\n    if (this.hasStarted && !this.isSeeking) {\n      this.notify('seek');\n      this.isSeeking = true;\n    }\n  }\n\n  /**\n   * Sent to ComScore when the playback rate changes.\n   *\n   * @see https://github.com/SRGSSR/srgletterbox-web/issues/761\n   * @see https://jira.srg.beecollaboration.com/browse/ADI-256\n   */\n  rateChange() {\n    this.notify('change_playback_rate');\n  }\n\n  /**\n   * Reload the tagCommander container and set all ComScore labels\n   */\n  reloadTagCommanderContainer() {\n    if (window.tC) {\n      window.tC.container.reload();\n      this.pendingTagCommanderReload = false;\n    } else {\n      this.pendingTagCommanderReload = true;\n    }\n  }\n\n  /**\n   * Sent when the current time is modified by the player's currentTime API.\n   *\n   * @see https://docs.videojs.com/player#event:seeking\n   */\n  seeking() {\n    if (this.hasStarted && !this.player.paused() && !this.isSeeking) {\n      this.notify('seek');\n      this.isSeeking = true;\n    }\n  }\n\n  /**\n   * Track current time updates delayed by a tick.\n   *\n   * @see https://docs.videojs.com/player#event:timeupdate\n   */\n  timeUpdate() {\n    if (!this.player.paused()) {\n      this.trackedCurrentTime = this.player.currentTime();\n    }\n  }\n\n  /**\n   * Gets the number of seconds that separate from the live edge that is represented by 0.\n   *\n   * @returns {String}\n   */\n  timeShifted() {\n    const isAtLiveEdge = this.player.liveTracker.atLiveEdge();\n    const liveCurrentTime = this.player.liveTracker.liveCurrentTime();\n    const currentTime = this.player.currentTime();\n    const timeShifted = isAtLiveEdge\n      ? 0\n      : (liveCurrentTime - currentTime).toFixed(0);\n\n    return timeShifted;\n  }\n\n  /**\n   * Update the src media data.\n   */\n  updateSrcMediaData(srcMediaData) {\n    this.srcMediaData = srcMediaData;\n  }\n\n  /**\n   * Calculate the uptime when playing a live stream with or without DVR\n   *\n   * __Rules__:\n   * - Send the first uptime after 30 seconds\n   * - Send uptime each 60 seconds after the 30 seconds\n   * - Uptime is sent only when playing\n   */\n  uptime() {\n    const notifyUptime = () => {\n      if (!this.player.paused() && !this.isMediaOnDemand()) {\n        this.notify('uptime');\n      }\n    };\n\n    // Send the first uptime after 30 seconds\n    this.uptimeTimeoutId = setTimeout(() => {\n      // Send only when playing\n      notifyUptime();\n\n      // Initialize the uptime interval after 30 seconds\n      this.uptimeIntervalId = setInterval(() => {\n        // Send only when playing\n        notifyUptime();\n      }, 60000);\n    }, 30000);\n  }\n\n  /**\n   *  __ComScore__:\n   * It's expected notifyBufferStart() to be called when the player starts buffering\n   * and a call to notifyBufferStop() when content resumes after buffering.\n   *\n   * @see Item 2: https://jira.srg.beecollaboration.com/browse/PLAY-2628\n   *\n   * After the issue PLAYRTS-321\n   * @see Fix: https://jira.srg.beecollaboration.com/browse/PLAYRTS-321?focusedCommentId=201023&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-201023\n   * @see Fix: https://jira.srg.beecollaboration.com/browse/PLAYRTS-3065\n   */\n  waiting() {\n    if (!this.initialized || this.isWaiting) {\n      return;\n    }\n\n    const bufferStop = () => {\n      this.isWaiting = false;\n      this.notify('buffer_stop');\n    };\n\n    this.isWaiting = true;\n\n    this.notify('buffer_start');\n\n    // As Safari is not consistent with its playing event, it is better to use the timeupdate event.\n    if (Pillarbox.browser.IS_ANY_SAFARI) {\n      this.player.one(PlayerEvents.TIME_UPDATE, bufferStop);\n    } else {\n      // As Chromium-based browsers are not consistent with their timeupdate event, it is better to use the playing event.\n      // Firefox is consistent with its playing event.\n      this.player.one(PlayerEvents.PLAYING, bufferStop);\n    }\n  }\n}\n\nexport default SRGAnalytics;\n","import Pillarbox from '../pillarbox.js';\nimport * as vjsLang from 'video.js/dist/lang/de.json';\nimport * as pillarboxLang from './de.json';\n\nPillarbox.addLanguage('de', {\n  ...vjsLang,\n  ...pillarboxLang,\n});\n","import Pillarbox from '../pillarbox.js';\nimport * as vjsLang from 'video.js/dist/lang/en.json';\nimport * as pillarboxLang from './en.json';\n\nPillarbox.addLanguage('en', {\n  ...vjsLang,\n  ...pillarboxLang,\n});\n","import Pillarbox from '../pillarbox.js';\nimport * as vjsLang from 'video.js/dist/lang/fr.json';\nimport * as pillarboxLang from './fr.json';\n\nPillarbox.addLanguage('fr', {\n  ...vjsLang,\n  ...pillarboxLang,\n});\n","import Pillarbox from '../pillarbox.js';\nimport * as vjsLang from 'video.js/dist/lang/it.json';\nimport * as pillarboxLang from './it.json';\n\nPillarbox.addLanguage('it', {\n  ...vjsLang,\n  ...pillarboxLang,\n});\n","import Pillarbox from '../pillarbox.js';\nimport * as pillarboxLang from './rm.json';\n\nPillarbox.addLanguage('rm', {\n  ...pillarboxLang,\n});\n","import Pillarbox from '../../src/pillarbox.js';\nimport DataProvider from '../dataProvider/services/DataProvider.js';\nimport Image from '../utils/Image.js';\nimport Drm from '../utils/Drm.js';\nimport AkamaiTokenService from '../utils/AkamaiTokenService.js';\nimport SRGAnalytics from '../analytics/SRGAnalytics.js';\n\n// Translations\nimport '../lang/de.js';\nimport '../lang/en.js';\nimport '../lang/fr.js';\nimport '../lang/it.js';\nimport '../lang/rm.js';\n\n/**\n * @class SrgSsr\n */\nclass SrgSsr {\n  /**\n   * Set a blocking reason according to the block reason returned\n   * by mediaData.\n   *\n   * @param {import('video.js/dist/types/player').default} player\n   * @param {String} blockReason\n   * @param {Object} srcMediaObj\n   *\n   * @returns {undefined|Boolean}\n   */\n  static blockingReason(player, blockReason, srcMediaObj) {\n    if (!blockReason) return;\n\n    const message = player.localize(blockReason);\n\n    SrgSsr.error(player, {\n      code: MediaError.MEDIA_ERR_ABORTED,\n      message,\n      metadata: { errorType: blockReason, src: srcMediaObj },\n    });\n\n    return true;\n  }\n\n  /**\n   * Add the Akamai token to all resources\n   * if at least one of them has tokenType\n   * set to Akamai.\n   *\n   * @param {Array.<Object>} resources\n   *\n   * @returns {Promise<Array.<Object>>}\n   */\n  static async composeAkamaiResources(resources = []) {\n    if (!AkamaiTokenService.hasToken(resources)) {\n      return Promise.resolve(resources);\n    }\n\n    // TODO allow to modify the Akamai URL\n    return AkamaiTokenService.tokenizeSources(resources);\n  }\n\n  /**\n   * Add the keySystems property to all resources\n   * if at least one of them has DRM.\n   *\n   * @param {Array.<Object>} resources\n   *\n   * @returns {Array.<Object>}\n   */\n  static composeKeySystemsResources(resources = []) {\n    if (!Drm.hasDrm(resources)) resources;\n\n    return resources.map((resource) => ({\n      ...resource,\n      ...Drm.buildKeySystems(resource.drmList),\n    }));\n  }\n\n  /**\n   * Get the main resources from a mediaComposition.\n   * May add an Akamai token or key systems if required by the resource.\n   *\n   * @param {import('../dataProvider/model/MediaComposition.js').default} mediaComposition\n   *\n   * @returns {Promise<Array.<Object>>}\n   */\n  static composeMainResources(mediaComposition) {\n    return SrgSsr.composeAkamaiResources(\n      SrgSsr.composeKeySystemsResources(\n        SrgSsr.filterIncompatibleResources(mediaComposition.getMainResources())\n      )\n    );\n  }\n\n  /**\n   * Compose source options with media data.\n   * MediaData properties from source options overwrite mediaData from IL.\n   *\n   * @param {Object} srcOptions - provided by player.src\n   * @param {Object} mediaData - provided by mediaComposition\n   *\n   * @returns {Object}\n   */\n  static composeSrcMediaData(\n    { mediaData: srcMediaData, disableTrackers },\n    { url, mimeType, keySystems, ...mediaData }\n  ) {\n    return {\n      src: url,\n      type: mimeType,\n      keySystems,\n      disableTrackers,\n      mediaData: Pillarbox.obj.merge(mediaData, srcMediaData),\n    };\n  }\n\n  /**\n   * SRG SSR data provider singleton.\n   *\n   * @param {import('video.js/dist/types/player').default} player\n   *\n   * @returns {DataProvider}\n   */\n  static dataProvider(player) {\n    if (!player.options().srgOptions.dataProvider) {\n      const { dataProviderHost } = player.options().srgOptions;\n      const dataProvider = new DataProvider(dataProviderHost);\n\n      player.options({\n        srgOptions: {\n          dataProvider,\n        },\n      });\n    }\n\n    return player.options().srgOptions.dataProvider;\n  }\n\n  /**\n   * Set an error if something goes wrong with the data provider.\n   *\n   * @param {import('video.js/dist/types/player').default} player\n   * @param {Object} error\n   *\n   * @returns {undefined|true}\n   */\n  static dataProviderError(player, error) {\n    const hasError =\n      error.url && error.url.includes(SrgSsr.dataProvider(player).baseUrl);\n\n    if (!hasError) return;\n\n    SrgSsr.error(player, {\n      code: 0,\n      message: player.localize('UNKNOWN'),\n      metadata: {\n        errorType: 'UNKNOWN',\n        urn: player.src(),\n        status: error.status,\n        statusText: error.statusText,\n        url: error.url,\n      },\n    });\n\n    return true;\n  }\n\n  /**\n   * Set player error.\n   *\n   * @param {import('video.js/dist/types/player').default} player\n   * @param {Object} error\n   */\n  static error(player, { code, message, metadata }) {\n    player.error(null);\n\n    player.error({\n      code,\n      message,\n      metadata,\n    });\n  }\n\n  /**\n   * Filter out incompatible resources such as `RTMP` and `HDS`.\n   *\n   * @param {Array.<Object>} resources Resources to filter\n   *\n   * @returns {Array.<Object>} The filtered resources\n   */\n  static filterIncompatibleResources(resources = []) {\n    return resources.filter(\n      (resource) => !['RTMP', 'HDS'].includes(resource.streaming)\n    );\n  }\n\n  /**\n   * Get mediaComposition from an URN.\n   *\n   * @param {String} urn\n   * @param {DataProvider} dataProvider\n   *\n   * @returns {Promise<{mediaComposition: import('../dataProvider/model/MediaComposition.js').default}>}\n   */\n  static async getMediaComposition(urn, dataProvider = new DataProvider()) {\n    return dataProvider.getMediaCompositionByUrn(urn);\n  }\n\n  /**\n   * Get the mediaData most likely to be compatible depending on the browser.\n   *\n   * @param {Array.<Object>} resources\n   *\n   * @returns {Object} By default, the first entry is used if none is compatible.\n   */\n  static getMediaData(resources = []) {\n    if (AkamaiTokenService.hasToken(resources)) return resources[0];\n\n    const type = Pillarbox.browser.IS_ANY_SAFARI ? 'HLS' : 'DASH';\n    const resource = resources.find(({ streaming }) => streaming === type);\n\n    return resource || resources[0];\n  }\n\n  /**\n   * SRG SSR analytics singleton.\n   *\n   * @param {import('video.js/dist/types/player').default} player\n   */\n  static srgAnalytics(player) {\n    if (player.options().trackers.srgAnalytics === false) return;\n\n    if (!player.options().trackers.srgAnalytics) {\n      const srgAnalytics = new SRGAnalytics(player, {\n        debug: player.debug(),\n        playerVersion: Pillarbox.VERSION.pillarbox,\n        tagCommanderScriptURL:\n          player.options().srgOptions.tagCommanderScriptURL,\n      });\n\n      player.options({\n        trackers: {\n          srgAnalytics,\n        },\n      });\n    }\n  }\n\n  /**\n   * Update player's poster.\n   *\n   * @param {import('video.js/dist/types/player').default} player\n   * @param {import('../dataProvider/model/MediaComposition.js').default} mediaComposition\n   * @param {Image} imageService\n   */\n  static updatePoster(player, mediaComposition, imageService = Image) {\n    player.poster(\n      imageService.scale({\n        url: mediaComposition.getMainChapterImageUrl(),\n      })\n    );\n  }\n\n  /**\n   * Update player titleBar with title and description.\n   *\n   * @param {import('video.js/dist/types/player').default} player\n   * @param {import('../dataProvider/model/MediaComposition.js').default} mediaComposition\n   */\n  static updateTitleBar(player, mediaComposition) {\n    if (!player.titleBar) return;\n\n    player.titleBar.update({\n      title: mediaComposition.getMainChapter().vendor,\n      description: mediaComposition.getMainChapter().title,\n    });\n  }\n\n  /**\n   * Middleware to resolve SRG SSR URNs into playable media.\n   *\n   * @param {import('video.js/dist/types/player').default} player\n   * @param {Image} imageService\n   *\n   * @returns {Object}\n   */\n  static middleware(player, imageService = Image) {\n    return {\n      /* eslint max-statements: [\"error\", 15]*/\n      setSource: async (srcObj, next) => {\n        try {\n          const { src: urn, ...srcOptions } = srcObj;\n          const { mediaComposition } = await SrgSsr.getMediaComposition(\n            urn,\n            SrgSsr.dataProvider(player)\n          );\n          const mainResources = await SrgSsr.composeMainResources(\n            mediaComposition\n          );\n          const mediaData = SrgSsr.getMediaData(mainResources);\n          const srcMediaObj = SrgSsr.composeSrcMediaData(srcOptions, mediaData);\n\n          SrgSsr.srgAnalytics(player);\n          SrgSsr.updateTitleBar(player, mediaComposition);\n          SrgSsr.updatePoster(player, mediaComposition, imageService);\n\n          if (SrgSsr.blockingReason(player, mediaData.blockReason, srcMediaObj))\n            return;\n\n          return next(null, srcMediaObj);\n        } catch (error) {\n          if (SrgSsr.dataProviderError(player, error)) return;\n\n          return next(error);\n        }\n      },\n    };\n  }\n}\n\nPillarbox.use('srgssr/urn', SrgSsr.middleware);\n\n// Add Middleware specific options\nPillarbox.options.srgOptions = {\n  dataProviderHost: undefined,\n  tagCommanderScriptURL: undefined,\n};\n\nexport default SrgSsr;\n"],"names":["vjsPlayer","videojs","getComponent","player","registerComponent","audioTrack","trackSelector","audioTracks","Array","from","this","find","enabled","kind","language","textTrack","textTracks","filter","includes","mode","forEach","pillarbox","VERSION","VhsSourceHandler","name","eme","getPlugin","options","enableSmoothSeeking","html5","vhs","useForcedSubtitles","liveTracker","trackingThreshold","liveTolerance","liveui","playsinline","plugins","responsive","trackers","MediaComposition","findChapterByUrn","urn","chapterList","chapter","element","findMainSegment","segmentUrn","segmentList","getMainSegments","segment","findResourceListByUrn","chapterByUrn","resourceList","getChapters","getFilteredExternalSubtitles","subtitleList","getMainChapter","subtitleInformationList","getResourceList","onlyHasExternalSubtitles","subtitles","subtitle","format","subtitleInformation","locale","type","getMainBlockReason","mainChapter","blockReason","Date","getMainValidFromDate","chapterUrn","length","getMainChapterImageUrl","imageUrl","getMainResources","map","resource","analyticsData","getMergedAnalyticsData","analyticsMetadata","getMergedAnalyticsMetadata","vendor","drmList","dvr","eventData","id","imageCopyright","live","mediaType","mimeType","presentation","quality","streaming","streamOffset","tokenType","url","mainSegments","validFrom","DataProvider","constructor","hostName","setIlHost","baseUrl","getMediaCompositionByUrn","onlyChapters","response","fetch","ok","data","json","mediaComposition","Object","assign","SCALE","FORMAT","Image","scale","width","imageServiceUrl","scaleUrl","URL","searchParams","set","decodeURIComponent","href","JPG","PNG","WEBP","WIDTH_240","WIDTH_320","WIDTH_480","WIDTH_960","WIDTH_1920","DRM_VENDORS","WIDEVINE","FAIRPLAY","PLAYREADY","Drm","buildKeySystems","keySystems","drmVendor","vendors","certificateUrl","certificateUri","licenseUrl","licenseUri","hasDrm","resources","some","TOKEN_TYPES","AkamaiTokenService","aclPath","streamUrl","path","pathname","substring","lastIndexOf","AKAMAI","hasToken","isAkamai","tokentype","isNone","NONE","tokenize","source","tokenServerUrl","streamUrlToTokenize","acl","encodeURIComponent","then","Promise","reject","status","statusText","token","authparams","URLSearchParams","v","k","toString","catch","reason","tokenizeSources","sources","tokenizedSources","tokenizedSource","push","all","values","EMPTIED","ENDED","LOADED_DATA","LOAD_START","PAUSE","PLAY","PLAYING","RATE_CHANGE","SEEKING","TIME_UPDATE","WAITING","SRGAnalytics","debug","environment","playerVersion","tagCommanderScriptURL","isDebugEnabled","elapsedPlaybackTime","hasStarted","heartBeatIntervalId","undefined","initialized","isSeeking","isWaiting","mediaSession","pendingQueue","pendingTagCommanderReload","srcMediaData","startPlaybackSession","trackedCurrentTime","uptimeIntervalId","initScript","initListeners","beforeunload","notify","clearTimers","clearInterval","clearTimeout","uptimeTimeoutId","currentTime","Math","round","Boolean","destroy","window","tc_vars","dispose","removeEventListener","beforeunloadListener","off","PlayerEvents.EMPTIED","emptiedListener","PlayerEvents.ENDED","endedListener","PlayerEvents.LOAD_START","loadstartListener","PlayerEvents.LOADED_DATA","loadeddataListener","PlayerEvents.PLAYING","playListener","PlayerEvents.PAUSE","pauseListener","PlayerEvents.RATE_CHANGE","rateChangeListener","PlayerEvents.SEEKING","seekingListener","PlayerEvents.TIME_UPDATE","timeUpdateListener","PlayerEvents.WAITING","waitingListener","emptied","ended","flush","isTrackerDisabled","tC","container","reload","tc_events_11","notification","el","action","labels","getCurrentAudioTrack","currentTrack","track","toUpperCase","getCurrentTextTrack","getDvrWindowPosition","ct","seekableStart","position","liveWindow","Infinity","getDvrWindowSize","isInfinity","windowSize","getElapsedPlaybackTime","getElapsedPlayingTime","playingSession","now","getEventLabels","eventName","event_id","event_timestamp","media_dvr_window_length","media_dvr_window_offset","media_is_dvr","media_is_live","media_mute","muted","media_playback_rate","playbackRate","media_position","media_quality","mediaData","media_subtitles_on","isTextTrackEnabled","media_volume","volume","toFixed","navigation_environment","isAudioTrackEnabled","media_audio_track","media_subtitle_selection","isMediaOnDemand","isMediaDvr","media_timeshift","PlayerEvents.PLAY","timeShifted","getInternalLabels","media_bu_distributer","media_chromecast_selected","tech","isCasting","media_embedding_url","document","referrer","media_player_display","media_player_name","media_player_version","media_url","src","heartBeat","setInterval","paused","initCallbacks","bind","loadstart","loadeddata","play","pause","rateChange","seeking","timeUpdate","waiting","addEventListener","on","one","scriptId","querySelector","script","createElement","defer","onload","_e","body","appendChild","isMediaLive","Number","isFinite","duration","isArray","disableTrackers","tracker","toLowerCase","updateSrcMediaData","currentSource","reloadTagCommanderContainer","log","eventMetadata","severity","console","error","uptime","isAtLiveEdge","atLiveEdge","liveCurrentTime","notifyUptime","setTimeout","bufferStop","Pillarbox","browser","IS_ANY_SAFARI","addLanguage","vjsLang","pillarboxLang","SrgSsr","blockingReason","srcMediaObj","message","localize","code","MediaError","MEDIA_ERR_ABORTED","metadata","errorType","composeAkamaiResources","resolve","composeKeySystemsResources","composeMainResources","filterIncompatibleResources","composeSrcMediaData","obj","merge","dataProvider","srgOptions","dataProviderHost","dataProviderError","getMediaComposition","getMediaData","srgAnalytics","updatePoster","imageService","poster","updateTitleBar","titleBar","update","title","description","middleware","setSource","async","srcObj","next","srcOptions","mainResources","use"],"mappings":"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"}